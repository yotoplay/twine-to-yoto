import fs from 'fs';
import path from 'path';
import { InputConfig, OutputConfig } from '../types/file.js';
import { TweeJSON } from '../types/twee.js';
import { YotoJSON } from '../types/yoto.js';
import { generateSha256Base64Filename } from '../utils/hashFilenames.js';
import { generateTracks } from '../twee2yoto.js';
import {
    getPassagesWithoutAudio,
    autoGenerateAudioTracks
} from './audioGenerator';

export async function handleProvidedAudio(
    input: InputConfig,
    output: OutputConfig,
    yotoJson: YotoJSON
) {
    // get pre provided audio files
    const allowedExtensions = ['.mp3', '.wav', '.ogg', '.flac', '.m4a', '.aac'];
    const providedAudioFiles = fs.readdirSync(input.audioDir).filter((file) => {
        const ext = path.extname(file).toLowerCase();
        return allowedExtensions.includes(ext);
    });

    for await (const file of providedAudioFiles) {
        // for each file, generate a sha256 hash and write to output directory
        const buffer = fs.readFileSync(path.join(input.audioDir, file));
        const sha256 = await generateSha256Base64Filename(buffer);
        const outputPath = path.join(output.audioDir, sha256);
        fs.writeFileSync(outputPath, buffer);

        // update yotoJson with the new track url
        const trackKey = path.basename(file, path.extname(file));
        updateTrackUrls(trackKey, sha256, yotoJson);
    }
    return providedAudioFiles;
}

export async function handleAutoGeneratedAudio(
    providedAudioFiles: string[],
    output: OutputConfig,
    tweeJson: TweeJSON,
    yotoJson: YotoJSON
) {
    if (!tweeJson.variables.defaultVoiceId) {
        throw new Error('No defaultVoiceId found in .twee');
    }

    // get passages without audio
    const { passages, variables } = tweeJson;
    const choiceTemplates = [
        variables.lhbTemplate || '',
        variables.rhbTemplate || ''
    ];
    const passagesWithoutAudio = getPassagesWithoutAudio(
        passages,
        providedAudioFiles
    );
    // generate audio tracks for these
    const autoGenerated = await autoGenerateAudioTracks(
        variables.defaultVoiceId,
        passagesWithoutAudio,
        choiceTemplates,
        output.audioDir
    );
    // update yotoJson with the generated tracks urls
    for (const track of generateTracks(autoGenerated)) {
        if (!track.trackUrl) {
            continue;
        }
        updateTrackUrls(track.key, track.trackUrl, yotoJson);
    }
    return autoGenerated.length;
}

export function updateTrackUrls(
    trackKey: string,
    trackUrl: string,
    yotoJson: YotoJSON
) {
    if (!trackUrl) {
        throw new Error(`No trackUrl found for ${trackKey}`);
    }
    const chapterKey = trackKey.split('_')[0];
    const passage = yotoJson.content.chapters.find((p) => p.key === chapterKey);
    if (!passage) {
        console.error(`Could not find passage for ${chapterKey}`);
        return;
    }
    const track = passage.tracks.find((t) => t.key === trackKey);
    if (!track) {
        throw new Error(`No track found with file name ${trackKey}`);
    }
    track.trackUrl = `yoto:#${trackUrl}`;
}
