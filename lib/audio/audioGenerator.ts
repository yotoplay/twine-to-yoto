import pLimit from 'p-limit';
import path from 'path';
import fs from 'fs';
import { textToSpeech } from '../apis/api.elevenlabs';
import { Choice, Passage } from '../types/twee';
import { generateSha256Base64Filename } from '../utils/hashFilenames';
import { AutoGeneratedAudio } from '../types/yoto';

const PARALLELL_LIMIT = 15;

export const autoGenerateAudioTracks = async (
    voiceId: string,
    passages: {
        passagesWithoutAudio: Passage[];
    },
    choiceSuffices: string[],
    outputDir: string
): Promise<AutoGeneratedAudio[]> => {
    const limit = pLimit(PARALLELL_LIMIT);
    const { passagesWithoutAudio } = passages;
    const audioGenerationPromises = passagesWithoutAudio.map((passage) =>
        limit(async () => {
            const { choices, content, name } = passage;
            const passageKey = name;
            const choicesText = choices
                .map(
                    (choice: Choice, index: number) =>
                        `${choice.text}${
                            index === 0
                                ? choiceSuffices[0] || ''
                                : choiceSuffices[1] || ''
                        }`
                )
                .join(' ');

            const contentText = content.concat(' ', choicesText);

            // Update passage
            const contentFilename = await generateSha256Base64Filename(
                Buffer.from(contentText.concat(voiceId))
            );
            const contentTrackPath = path.join(outputDir, contentFilename);
            if (!fs.existsSync(contentTrackPath)) {
                const { data } = await textToSpeech(contentText, voiceId);
                fs.writeFileSync(contentTrackPath, data, {
                    encoding: 'binary'
                });
            }

            return {
                key: passageKey,
                type: 'content',
                choices,
                content: contentText,
                audioUrl: contentFilename
            };
        })
    );
    const audioTracks = await Promise.all([...audioGenerationPromises]);

    const merged: AutoGeneratedAudio[] = [];
    audioTracks.forEach((track) => {
        const { key, content, choices, audioUrl } = track;

        const passage = merged.find((p) => p.key === key);
        if (!passage) {
            merged.push({
                key,
                choices,
                content,
                contentAudioUrl: audioUrl
            });
        } else {
            passage.choices = choices || [];
            passage.content = content;
            passage.contentAudioUrl = audioUrl;
        }
    });
    return merged;
};

export function getPassagesWithoutAudio(
    passages: Passage[],
    audioFiles: string[]
) {
    const passagesWithoutAudio: Passage[] = [];
    const audioFilesWithoutExtension = audioFiles.map(
        (file) => path.parse(file).name
    );
    for (const passage of passages) {
        if (!audioFilesWithoutExtension.includes(`${passage.name}`)) {
            passagesWithoutAudio.push(passage);
        }
    }
    return {
        passagesWithoutAudio
    };
}
