import fs from "fs";
import path from "path";
import { InputConfig, OutputConfig } from "../types/file.js";
import { TweeJSON } from "@yotoplay/twee2json";
import { YotoJSON } from "@yotoplay/twee2yoto";
import { generateSha256Base64Filename } from "../utils/hashFilenames.js";
import { generateTracks } from "@yotoplay/twee2yoto";
import {
  getPassagesWithoutAudio,
  autoGenerateAudioTracks,
} from "./audioGenerator";
import { getElevenLabsApiKeyIfAvailable } from "../auth/elevenLabsAuth.js";
import { logger } from "../utils/logger.js";

export async function handleProvidedAudio(
  input: InputConfig,
  output: OutputConfig,
  yotoJson: YotoJSON,
) {
  // get pre provided audio files
  const allowedExtensions = [".mp3", ".wav", ".ogg", ".flac", ".m4a", ".aac"];
  const providedAudioFiles = fs.readdirSync(input.audioDir).filter((file) => {
    const ext = path.extname(file).toLowerCase();
    return allowedExtensions.includes(ext);
  });

  for await (const file of providedAudioFiles) {
    // for each file, generate a sha256 hash and write to output directory
    const buffer = fs.readFileSync(path.join(input.audioDir, file));
    const sha256 = await generateSha256Base64Filename(buffer);
    const outputPath = path.join(output.audioDir, sha256);
    fs.writeFileSync(outputPath, buffer);

    // update yotoJson with the new track url
    const trackKey = path.basename(file, path.extname(file));
    updateTrackUrls(trackKey, sha256, yotoJson);
  }
  return providedAudioFiles;
}

export async function handleAutoGeneratedAudio(
  providedAudioFiles: string[],
  output: OutputConfig,
  tweeJson: TweeJSON,
  yotoJson: YotoJSON,
) {
  // Check if ElevenLabs API key is available
  const apiKey = await getElevenLabsApiKeyIfAvailable();
  if (!apiKey) {
    logger.warn("ElevenLabs API key not available - skipping automatic audio generation");
    return 0;
  }

  if (!tweeJson.variables.defaultVoiceId) {
    throw new Error("No defaultVoiceId found in .twee");
  }

  // get passages without audio
  const { passages, variables } = tweeJson;
  const choiceTemplates = [
    variables.lhbTemplate || "",
    variables.rhbTemplate || "",
  ];
  const passagesWithoutAudio = getPassagesWithoutAudio(
    passages,
    providedAudioFiles,
  );
  // generate audio tracks for these
  const autoGenerated = await autoGenerateAudioTracks(
    variables.defaultVoiceId,
    passagesWithoutAudio,
    choiceTemplates,
    output.audioDir,
  );
  // update yotoJson with the generated tracks urls
  // Use passage name (which matches chapter key) directly for accurate lookup
  for (const passage of autoGenerated) {
    const passageName = passage.key; // This is the passage name, which should match the chapter key
    for (const track of generateTracks([passage])) {
      if (!track.trackUrl) {
        continue;
      }
      updateTrackUrls(track.key, track.trackUrl, yotoJson, passageName);
    }
  }
  return autoGenerated.length;
}

export function updateTrackUrls(
  trackKey: string,
  trackUrl: string,
  yotoJson: YotoJSON,
  chapterKey?: string,
) {
  if (!trackUrl) {
    throw new Error(`No trackUrl found for ${trackKey}`);
  }
  
  // Use provided chapterKey if available, otherwise try to extract from trackKey
  const chapterKeyToFind = chapterKey || trackKey.split("_")[0];
  
  const passage = yotoJson.content.chapters.find((p) => p.key === chapterKeyToFind);
  if (!passage) {
    console.error(`Could not find chapter with key "${chapterKeyToFind}" for track "${trackKey}"`);
    return;
  }
  const track = passage.tracks.find((t) => t.key === trackKey);
  if (!track) {
    throw new Error(`No track found with key "${trackKey}" in chapter "${chapterKeyToFind}"`);
  }
  track.trackUrl = `yoto:#${trackUrl}`;
}
